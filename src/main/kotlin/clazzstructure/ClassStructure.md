# 클래스 계층 구조 

## 상속
- 도메인 개념에 있는 is-a 관계를 표현하기 위해 대부분의 객체지향 언어는 상속이라는 개념 사용
- 클래스 A가 B를 상속한다.
  - A의 인스턴스는 자동으로 B의 인스턴스로 간주
  - A는 B에 정의된 모든 멤버와 확장을 자동으로 얻음
- 자바처럼 단일 상속만 지원
- 상속을 명시하지 않으면 컴파일러가 자동으로 Any 상속
- 프로그램의 모든 클래스는 상속 트리 구성 -> 클래스 계층
- 코틀린은 extends 등의 특별한 키워드 사용 x
  - 하위 클래스를 정의하면서 상위 클래스에 괄호를 붙인 이유?
    - 생성자를 호출하기 위함
    - 상위 클래스에 필요한 인자가 있으면 괄호 사이에 넣어야 함
- open
  - 변경자는 해당 클래스가 상속에 대해 열려 있음 
  - 일반적으로 코틀린은 final 클래스가 default 이므로 상속이 가능하도록 하려면 open으로 열어주어야 함
- 자바는 기본이 default, 상속 불가 클래스는 final / 코틀린은 기본이 final
- 데이터 클래스는 코틀린 1.1부터 상속 가능
- 인라인 클래스는 다른 클래스 상속할 수 없음
- 임의 다형성을 제공하므로 상황에 따라 필요한 함수만 오버라이드 할 수 있도록 할 수 있음
  - 코틀린은 함수와 프로퍼티가 기본적으로 final
    - 하위 클래스에서 오버라이드하게 허용하려면 open을 명시해야 함
  - open + override를 명시 해야함
    - 자바에서는 @Override를 빼도 동작하지만 코틀린은 엄격하게 override 명시
- 확장함수는 정적으로 동작하므로, 상속의 경우 런타임에 결정되는 코드가 존재할 때 확장 함수가 적용되지 않음


## 프로퍼티 상속 가능성
```kotlin
open class Entity {
    open val name: String get() = ""
    open val address: String get() = ""
}

class Person(
    override val name: String,
    override var address: String,
) : Entity()
```
- 코틀린은 java와 달리 프로퍼티를 직접 제공
- 프로퍼티는 필드. 게터, 세터를 포함할 수 있음
- val 프로퍼티는 읽기 전용이므로 게터만 있고, var은 가변적이므로 게터와 세터를 모두 가질 수 있음
- 프로퍼티 상속 가능성
  - Entity 클래스에 있는 name, address는 모두 open 프로퍼티
  - open 키워드는 해당 프로퍼티나 메서드를 하위 클래스에서 오버라이드 할 수 있도록 허용
  - 부모 클래스의 프로퍼티를 오버라이드 할 수 있음
- val -> var 오버라이드
  - val은 읽기 전용이므로 게터만 존재
  - var은 게터와 세터가 존재하므로 오버라이드 하는 것은 세터를 추가하는 것과 같음
  - var -> val 은 불가