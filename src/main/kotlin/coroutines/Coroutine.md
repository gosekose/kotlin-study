# 코루틴

- 코루틴을 쓰지 않는다면 ?
    - 자바 동기 프로그래밍
        - 자바 동시성 요소는 대부분 blocking 연산
        - Thread.sleep(), Thread.join(), Object.wait() 는 실행 종료시점까지 기다림
        - 스레드를 블럭하고 나중에 실행을 재개하려면 시스템 수준에서 계산 비용이 많이 드는 컨텍스트 스위칭을 해야함
        - 시스템에 부정적인 영향을 미칠 수 있음
        - 동시성 스레드를 많이 사용하는 것은 비실용적이거나 아예 불가능
    - 비동기 프로그래밍
        - 동시성 연산에 대한 해당 연산이 완료될 때, 호출될 수 있는 람다를 제공
        - 원래 스레드는 블럭된 상태로 작업 완료를 기다리는 대신 다른 유용한 작업을 계속 수행할 수 있음
        - 일반적인 명령형 제어 흐름을 사용할 수 없어서 코드 복잡도가 늘어남
- 코루틴은 두 가지 프로그래밍 장점을 함꼐 취할 수 있음
    - 명령형 스타일로 코드를 작성하면 컴파일러가 효율적인 비동기 계산으로 자동 변환함
    - 잠시 중단되었다가 나중에 중단한 시점부터 실행을 다시 재개할 수 있음
    - 일시 중단 가능한 함수라는 개념을 중심으로 이뤄짐
- 코루틴 기능이 별도의 라이브러리로 제공되므로 명시적으로 프로젝트 설정에 이를 추가해야함
    - "org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3"
- 코루틴은 스레드보다 훨씬 가벼움
    - 코루틴은 유지해야하는 상태가 더 간단, 일시 중단되고 재개될 떄 완전한 문맥 전환을 하지 않아도 되므로 엄청난 수의 코루틴을 충분히 동시에 실행 가능

### 코루틴 일시 중단 함수

- 코루틴 라이브러리를 뒷받침하는 기본 요소는 일시 중단 함수
- 이 함수는 일반적인 함수를 더 일반화해 함수 본문이 원하는 지점에서 함수에 필요한 모든 런타임 문맥을 저장
- 함수 실행을 중단한 후, 나중에 필요할 때 다시 실행을 계속 진행할 수 있도록 함
- suspend 변경자를 붙여서 사용 가능
- delay()
    - Thread.sleep()과 비슷한 일
    - 차이점은 현재 스레드를 블럭시키지 않고 자신을 호출한 다른 작업을 수행할 수 있게 풀어줌
- 일시 중단 함수는 일시 중단 함수와 일반 함수를 원하는 대로 호출할 수 있음
    - 일시 중단 함수를 호출하면 해당 호출 지점이 일시 중단 지점이 됨
    - 일시 중단 지점은 임시로 실행을 중단했다가 나중에 재개할 수 있는 지점
    - 코틀린은 일반 함수가 일시 중단 함수를 호출하는 것을 금지
- 코루틴 빌더
    - 어떻게 일반 함수가 일시 중단 함수를 호출할 수 있는가? -> 코루틴 빌더 사용
    - 동시성 코드의 동작을 제어하고 싶기 때문에 공통적인 생명 주기와 문맥이 정해진 몇몇 작업이 정의된 구체적인 영역 안에서 동시성 함수를 호출
    - Coroutines 인스턴스의 확장 함수로 쓰임
    - CoroutineScope에 대한 구현 중 가장 기본적인 것으로 GlobalScope 객체가 있음
    - 독립적인 코루틴을 만들 수 있고, 이 코루틴은 자신만의 작업을 내포할 수 있음
    - launch(), async(), runBlocking() 코루틴 빌더

### 구조화된 동시성 원칙

- 코루틴의 부모-자식 관계와 이 관계에서 동작 방식을 이해해야 함
- 구조화된 동시성 개념
    - 어떤 스코프 내에서 코루틴을 시작하면, 그 코루틴은 그 스코프의 "자식 코루틴이" 됨
    - 부모 코루틴(또는 스코프)이 종료되기 전에는 그 안에서 시작된 모든 자식 코루틴이 종료되어야 함

```
    fun main() = runBlocking{
        launch {
            delay(1000L)
            println("Inside coroutines")
        }
        println("Outside coroutines")
    }
```

### 자바와 코틀린에서 스레드 분류

- 주 스레드 (Main Thread)
    - 프로그램 진입점인 main() 함수에서 실행되는 스레드
    - 일반적으로 GUI 애플리케이션에서 UI 작업을 처리하는 스레드로 사용
    - 주 스레드는 일반적으로 사용자 스레드에 속함
- 사용자 스레드 (User Thread)
    - 직접 생성하여 시작한 스레드
    - Thread() 생성자를 사용하여 만든 스레드가 해당함
    - JVM은 모든사용자 스레드가 종료될 때까지 실행 상태를 유지함
- 데몬 스레드(Daemon Thread)
    - 백그라운드 작업을 위한 스레드
    - 주 스레드가 종료되면 데몬 스레드도 종료
    - 사용자 스레드와는 달리 JVM이 종료될 때 모든 데몬 스레드가 완료되었는지 확인하지 않음
    - JVM은 모든 사용자 스레드가 완료되면 즉시 종료되며 실행 중인 데몬 스레드의 상태에는 관심을 가지지 않음

### Scope

- GlobalScope
    - 코루틴을 전역적으로 실행하는데 사용되는 스코프
    - 이 스코프 내에서 시작된 코루틴은 앱의 전체 수명 동안 실행되며 조기에 취소되지 않음
    - 여러 문제점 내포
        - 구조화된 동시성 원칙 위반
            - 코루틴은 구조화된 동시성이라는 원칙으로 동작
            - 코루틴을 시작하는 코드 블록이 완료되기 전에 그 안에서 시작된 모든 코루틴이 완료되어야 함
            - GlobalScope는 이 원칙을 위반
        - 자원 및 메모리 누수
            - GlobalScope에서 시작된 코루틴은 애플리케이션의 수명동안 계속 실행 될 수 있음
        - 비동기 작업 관리의 부재
            - GlobalScope를 사용하여 시작된 코루틴은 자동으로 취소되거나 완료될 때까지 기다리는 매커니즘이 없음
    - optIn
        - 코틀린에서 안정성이 확보되지 않은 API 또는 실험적인 API를 사용할 떄 명시적으로 그 사용에 동의함
        - DelicateCoroutinesApi는 코루틴 라이브러리에서 부주의하게 사용될 경우 문제를 일으킬 수 있는 API 표시

### 코루틴 빌더

- launch()
    - 코루틴을 시작
    - 코루틴을 실행 중인 작업의 상태를 추적하고 변경할 수 있는 job 객체로 돌려 줌
    - 이 함수는 CoroutineScope.() -> Unit 타입의 일시 중단 람다를 받음
    - 각 코루틴이 병렬적으로 실행될 수 있음
    - 필요할 때 실행 순서를 강제할 수 있음
    - main() 함수 자체는 Thread.sleep()을 통해 메인 스레드 실행을 잠시 중단
    - 코루틴 스레드가 완료될 수 있도록 충분한 시간 제공
    - 코루틴을 처리하는 스레드는 데몬 모드로 실행
        - main() 스레드가 이 스레드보다 빨리 끝나버리면 자동으로 종료
    - 일시 중단 함수의 내부에서 sleep()과 같은 스레드를 블럭시키는 함수를 실행할 수 있지만 코루틴을 사용하는 목적이 위배됨
    - 일시 중단 함수인 delay()를 사용
    - launch 빌더는 동시성 작업이 결과를 만들어내지 않는 경우에 적합
    - 이 빌더는 Unit 타입을 반환하는 람다를 인자로 받음
- async()
  - 결과가 필요한 경우에는 async() 라는 다른 빌더 함수를 사용해야 함
  - 이 함수는 Defferred 인스턴스를 돌려줌
  - 이 인스턴스는 Job의 하위타입으로 await() 메서드를 통해 계산 결과에 접근
  - await() 메서드를 호출하면 await() 계산이 완료되거나 계산 작업이 취소될 떄까지 현재 코루틴은 일시 중단
  - 작업이 취소되는 경우 await()는 예외 발생시키면서 실패
  - async()를 자바의 퓨처에 해당하는 코루틴 빌더라고 생각할 수 있음
  - main()을 suspend로 표시해서 두 Deferred 작업에 대해 직접 await() 메서드를 호출함
  - launch() 와 async() 빌더의 경우 스레드 호출을 블럭시키지 않지만 백그라운드 스레드를 공유하는 풀을 통해 작업을 실행
  - 메인 스레드가 처리할 일이 별로 없었기 때문에 sleep()을 통해 백그라운드 스레드에서 실행되는 작업이 완료될 떄까지 기다려야 했음
  - 반대로 runBlocking() 빌더는 디폴트로 현재 스레드에서 실행되는 코루틴을 만들고 코루틴이 완료될 떄까지 현재 스레드의 실행을 블록시킴
  - 코루틴이 성공적으로 끝나면 일시 중단 람다의 결과가 runBlocking() 호출의 결괏값이 됨
  - 코루틴이 취소되면 runBlocking은 예외를 던짐
  - 반면에 블락된 스레드가 인터럽트되면 runBlocking()에 의해 시작된 코루틴도 취소됨