# 자바 코틀린 상호 운용성

### 자바 코드를 코틀린에서 사용하기
- 코틀린은 JVM을 주 대상으로 설계함
  - 코틀린에서는 항상 어떤 타입이 널이 될 수 있는 타입인지 아닌지 지정
  - 자바는 정보 부족
- Unit / void
  - 코틀린은 반환값이 없을을 나타내는 void 키워드가 없음
  - 자바 void 함수는 코틀린에서 Unit을 반환하는 함수로 보임
  - 이런 함수를 호출하고 호출 결과를 저장하여 컴파일러가 Unit 객체에 대한 참조를 생성한 후 저장
- 연산자 관습
  - Map.get() 같은 몇몇 자바 메서드는 코틀린의 연산자 관습을 만족
  - 코틀린 operator로 연산자 함수인 것처럼 활용 가능
- 합성 프로퍼티
  - 코틀린 컴파일러는 자바 게터나 세터를 일반적인 코틀린 프로퍼티처럼 쓸 수 있게 합성 프로퍼티 노출
  - 관습
    - 게터는 파라미터가 없는 메서드, 매서드 이름이 get으로 시작
    - 세터는 파라미터가 하나만 있는 메서드여야 하며, 메서드 이름이 set
- 플랫폼 타입
  - 자바는 널이 될 수 잇는 타입과 아닌 타입을 구분 x
  - 코틀린 컴파일러는 자바 코드가 노출하는 타입에 대한 널 안정성 검사를 완화
    - 자바 타입을 명확한 널 가능성이 지정되지 않은 타입으로 취급
    - 코틀린에서 자바 코드로부터 비롯된 객체는 플랫폼 타입이라는 특별한 타입에 속함
    - 플랫폼 타입은 널이 될 수 있는 타입이기도 하고 널이 될 수 없는 타입이기도 함
    - 타입에 대한 안정성 보증은 자바와 동일
    - 런타임 시점에 NPE 발생 가능

- 단일 추상 메서드 인터페이스
  - 추상 메서드가 하나뿐인 자바 인터페이스가 있다면 SAM 이라 부름
    - 단일 추상 메서드 (Single Abstract Method)
  - 이 인터페이스는 코틀린 함수 타입처럼 작동
  - 자동으로 람다와 적절한 SAM 타입 인스턴스 사이의 변환을 지원해주는 java 8+ 비슷
  - 코틀린은 SAM 인터페이스가 필요한 위치에 람다를 넘길 수 있게 지원

### 코틀린 코드를 자바에서 사용하기
- 프로퍼티 접근
  - 프로퍼티는 게터, 세터로 적용
  - 관습에 의해 Boolean은 isXXX으로 명하되, setter는 setXXX으로 적용됨
- @JvmField
  - 자바에서 직접 필드에 접근해야하는 니즈가 있는 경우
  - 자바의 필드처럼 사용

### 객체와 정적 멤버
- JVM에서 코틀린 객체 선언은 정적인 INSTANCE 필드가 있는 일반적인 클래스로 컴파일
- 자바코드에서는 XXX.INSTANCE 필드를 통해 객체의 멤버에 접근 가능
- @JvmField를 쓰면 객체 프로퍼티가 자바 입장에서 정적 필드로 바뀜
- 객체 함수나 프로퍼티 접근자를 정적 메서드로 만들면 편리함
- @JvmStatic 
  - 코틀린의 객체 선언(object) 또는 동반 객체(companion object) 내부의 함수나 프로퍼티를 자바의 정적 메서드나 필드로 사용 가능
  - 사용하지 않을 때는 MyClass.Companion.myMethod() 방식으로 호출 해야 함

### 오버로딩한 메서드 생성하기
- 코틀린은 default가 존재하므로 함수의 인자를 상황에 따라 다르게 처리 가능
- 자바는 default가 없으므로 코틀린 함수를 쓰게되면 모든 인자를 다 넣어야 함
- @JvmOverloads를 사용하면 오버로딩된 함수를 제공
  - 인자의 개수를 첫 번째, 첫 번째와 두 번쨰, .... 제공

### 예외 선언하기
- 코틀린이 검사 예외와 비검사 예외를 구분하지 않음
- 함수 프로퍼티는 예외의 유형과 무관하게 throws절 코드를 추가할 필요없이 예외를 던짐
- 자바는 명시적으로 함수 본문에서 처리하지 않고 외부로 던져지는 검사 예외 목록을 추가해야 함
  - 자바는 try - catch 안의 코드에서 발생하는 것으로 선언되지 않은 검사를 예외 catch로 처리하는 것을 금지
- @Throws(Exception이름::class)를 호출함으로써 자바에서 사용할 떄 예외에 대한 try-catch를 잡을 수 있음
- 코틀린 컴파일러는 기반 클래스의 멤버와 이 멤버를 오버라이딩한 자식 클래스의 멤버에 붙은 @Throws 애너테이션의 예외 선언의 일관성 검증 하지 않음
  - 기반 클래스의 메서드에서는 @Throws를 붙이지 않더라도 상속/구현하는 클래스의 메서드에서는 사용 가능

### 인라인 함수
- 자바에서는 인라인 함수가 없기 때문에 코틀린에서 inline 변경자가 붙은 함수는 일반 메서드로 자바에 노출
- 자바에서는 이런 메서드를 호출할 수 있지만 인라인 함수의 본문이 호출하는 자바 코드로 인라인은 불가

### 타입 별명
- 코틀린 타입 별명은 자바 코드에서 쓸 수 없음
- 자바에서 볼 떄 타입 별명을 참조하는 선언은 모두 원래 타입을 가리키는 것으로 보임