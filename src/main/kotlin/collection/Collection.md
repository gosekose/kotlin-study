# Collection

- 코틀린 컬렉션 타입은 기본적으로 네 가지로 분류 가능 
  - 배열, 이터러블, 시퀀스, 맵
- 배열과 비슷하게 컬렉션 타입도 제네릭 타입
  - 컬렉션의 타입을 구체적으로 지정하려면 원소의 타입을 지정해야 함


## 이터러블
- 이터러블은 Iterable<T> 타입으로 표현
- 즉시 계산되는 상태가 있는 컬렉션 
- 상태가 있다는 말은 컬렉션이 원소를 필요로 할 때 생성하는 제너레이터 함수를 유지하지 않고 원소를 저장
- 즉시 계산이라는 말은 나중에 어느 필요한 시점에 원소가 초기화되지 않고 컬렉션을 최초로 생성할 떄 초기화
- 자바의 이터러블 타입과 비슷
- 원소를 순회할 수 있는 iterator()라는 메서드를 제공
- for 루프에서는 이 메서드를 통해 모든 이터러블 객체를 활용 가능
- 코틀린의 iterator 타입은 기본적으로 자바와 동일
  - 내부에는 이터레이터가 컬렉션의 끝에 도달했는지 판단하는 hashNext()와 컬렉션의 다음 원소를 반환하는 next() 메서드가 있음
  - 유일한 차이는 remove()가 없음 -> MutableIterator로 옮겨짐
  - 자바와 비교할 떄 코틀린의 이터러블의 중요한 특징은 불변 컬렉션과 가변 컬렉션을 구분한다는 점
  - 불변 컬렉션은 생성한 다음에 내용을 바꿀 수 없지만, 가변 컬렉션은 언제든지 원소를 추가하거나 삭제할 수 잇음
  - 컬렉션의 변경 가능성은 컬렉션의 인스턴스에 대한 참조를 저장하는 변수의 변경 가능성과 아무런 관계가 없음.
  - val에 가변 컬렉션을 저장하고, 컬렉션에 값을 삭제, 추가할 수 있음
- 불변 컬렉션의 유용한 특징은 공변성 제공 
  - T가 U의 하위 타입인 경우 Iterable<T>도 Iterable<U>의 하위 타입

## 컬렉션, 리스트, 집합
- 리스트
  - 인덱스를 통한 원소 접근이 가능한 순서가 정해진 컬렉션
  - 일반적인 리스트 구현은 인덱스를 통한 임의 접근이 가능한 ArrayList와 원소를 빠르게 추가하거나 삭제할 수 있음
  - 인덱스로 접근할 경우 선형 시간 걸림
- 집합
  - 유일한 원소들로 이루어진 컬렉션, 원소의 순서는 구현에 따라 다름
    - HashSet: 해시 테이블이 기반인 구현, 원소의 해시코드에 따라 원소 순서가 정해짐
    - LinkedHashSet: 해시 테이블이 기반이지만 삽인 순서를 유지하기 때문에 이터레이션하면 집합에 삽입된 순서대로 순회
    - TreeSet: 이진 검색 트리가 기반, 어떤 규칙에 따라 일관성있는 원소 순서를 제공, 원소 타입이 이런 비교 규칙을 정의할 수 있고 별도의 Comparator 객체를 통해 비교 규칙 제공

## 시퀀스
- 이터러블과 비슷하게 시퀀스도 iterator() 메서드를 제공
- 시퀀스의 내용을 순회할 수 있음
- 시퀀스는 지연 계산을 가정하기 때문에 iterator()의 의도가 이터러블과 다름
- 시퀀스 구현은 객체 초기화 시 원소를 초기화 하지 않고 요청에 따라 원소를 계산
- 시퀀스는 구현 상태가 없음 
- 지연 계산한 컬렉션 원소 중에 정해진 개수의 원소만 저장함
- 이터러블은 원소 개수에 비례해 메모리를 사용함

## 맵
- 맵은 키와 값쌍으로 이루어진 집합
- 키는 유일해야 함
- 맵 자체는 Collection의 하위 타입이 아니지만 맵에 있는 원소들을 컬렉션처럼 사용 가능
- 맵으로부터 모든 키로 이뤄진 집합을 얻을 수 있음 
- 맵에는 두 가지 종류의 원소가 들어있기 때문에 맵의 타입은 두 가지 타입을 파라미터로 받는 제네릭 타입
- Map<Int, String>은 Int 키를 String 값에 연관시켜주는 맵 

## Comparable, Comparator
- 코틀린도 Comparable, Comparator 타입을 지원
- 비교 가능 인스턴스는 자연적인 순서를 지원, 이런 타입의 인스턴스들은 모두 돌인한 타입의 다른 인스턴스와 순서를 비교할 때 쓸 수 있는 compareTo() 메서드를 포함
- Comparable을 상속하면 자동으로 <> 등의 연산을 쓸 수 있고, 원소 타입이 비교 가능한 타입인 컬렉션의 순서 연산에도 이런 연산이 쓰임 

## 컬렉션 생성하기
- 배열 인스턴스를 생성자를 통해 생성하거나 arrayOf() 같은 표준 함수를 통해 생성할 수 있음
- 여러 표준 컬렉션 클래스의 인스턴스를 비슷한 방식으로 생성 가능
- 자바와 마찬가지로 ArrayList, LinkedHashSet과 같은 클래스의 인스턴스를 생성자로 호출할 수 있음
- arrayOf()
  - emptyList()/emptySet()
    - 불변인 빈 리스트/집합 인스턴스를 생성
  - listOf/setOf()
    - 인자로 제공한 배열(가변 길이 인자)에 기반한 불변 리스트/집합 인스턴스를 만듬
    - 리스트의 경우 listOf는 Arrays.asList()와 같음
  - listOfNotNull()
    - 널인 값을 걸러내고 남은 원소들로 이뤄진 새 불변 리스트를 만듬
  - mutableListOf()/mutableSetOf()
    - 가변 리스트/집합의 디폴트 구현 인스턴스를 만듬
  - arrayListOf()
    - 새로운 ArrayList()를 만듬
  - hashSetOf/linkedSetOf()/sortedSetOf()
    - HashSet()/LinkedHashSet/TreeSet의 새 인스턴스를 만듬
  - emptyMap()
    - 빈 불변 맵을 만듬
  - mapOf()
    - 불변 맵을 만듬 (내부적으로 LinkedHashMap)
  - mutableMapOf()
    - 가변 맵의 디폴트 구현 인스턴스를 만듬
    - 내부적으로 LinkedHashMap
  

## 컬렉션 연산
- 이터레이션
  - 배열, 이터러블, 시퀀스, 맵 -> iterator() 지원
- 불변 / 가변 컬렉션에 +- 연산 지원
  - 새로운 컬렉션을 생성
  - 새로운 컬렉션을 생성하므로 성능에 영향을 줌

## 집계
- reduce
  - 파라미터가 두 개인 함수를 받음
  - 첫 번째 인자는 누적된 값
  - 두 번째 인자는 컬렉션의 현재 값
    - 누적합은 최초에 컬렉션의 첫 번째 원소로 초기화
    - 컬렉션의 매 원소에 대해 현재 누적값과 현재 원소를 파라미터로 받은 함수에 적용하고 이 함수 적용의 결과를 누적값에 대입
    - 누적의 결과를 반환
  - 컬렉션이 비어있다면 누적값을 초기화할 수 없으므로 reduce() 함수는 예외를 던짐
  - 특정 인덱스만 적용해야한다면 reduceIndexed() 사용
  - 초기값은 인덱스에 상관없이 항상 더해짐
- fold
  - 초기값을 원하는대로 지정 가능
  - 컬렉션의 타입과 다른 타입으로 만들 수 있음